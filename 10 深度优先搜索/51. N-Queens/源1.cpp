#include <vector>

using namespace std;

class Solution {
public:
	vector<vector<string> > solveNQueens(int n) 
	{

		this->columns = vector<int>(n, 0);
		this->principal_diagonals = vector<int>(2 * n, 0);
		this->counter_diagonals = vector<int>(2 * n, 0);

		vector<vector<string> > result;
		vector<int> C(n, 0); // C[i] 表示第i 行皇后所在的列编号

		dfs(0, C, result);

		return result;
	}

private:

	// 这三个变量用于剪枝
	vector<int> columns; // 表示已经放置的皇后占据了哪些列
	vector<int> principal_diagonals; // 占据了哪些主对角线
	vector<int> counter_diagonals; // 占据了哪些副对角线

	void dfs(int row, vector<int> &C,	vector<vector<string> > &result) 
	{

		const int N = C.size();

		if (row == N)
		{ 
			// 终止条件，也是收敛条件，意味着找到了一个可行解
			vector<string> solution;
			for (int i = 0; i < N; ++i) 
			{
				string s(N, '.');
				for (int j = 0; j < N; ++j)
				{
					if (j == C[i])
					{
						s[j] = 'Q';
						break;
					}
				}
				solution.push_back(s);
			}
			result.push_back(solution);

			return;
		}

		for (int j = 0; j < N; ++j)
		{ 
			// 扩展状态，一列一列的试
			const bool ok = columns[j] == 0 && 
									principal_diagonals[row + j] == 0
									&& counter_diagonals[row - j + N] == 0;
			if (ok)
			{ 
				// 剪枝：如果合法，继续递归
				// 执行扩展动作
				C[row] = j;
				columns[j] = principal_diagonals[row + j] = counter_diagonals[row - j + N] = 1;

				dfs(row + 1, C, result);

				// 撤销动作
				// C[row] = 0;
				columns[j] = principal_diagonals[row + j] = counter_diagonals[row - j + N] = 0; 

			}
		}
	}
};